.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "ORCHA" "1" "Dec 23, 2021" "" "Orcha"
.SH NAME
orcha \- Orcha is an orchestrator for all your projects
.SH ORCHA PACKAGE
.SS Entry point
.SS orcha.bin
.sp
Main application entry point. Here, a single method is exposed which prepares
the environment for running the application with the installed plugins. Notice
that \fIorcha.main\fP won\(aqt work if no plugin is installed. For more information,
see: \fBBasePlugin\fP\&.
.sp
Orcha entrypoints
.INDENT 0.0
.TP
.B orcha.bin.main()
Main application entry point. Multiple arguments are defined which allows
further customization of the server/client process:
.INDENT 7.0
.TP
.BI \-\-listen\-address \ ADDRESS
defines the IP address used when serving/connecting the
application. By default, it is \fB127.0.0.1\fP\&.
.TP
.BI \-\-port \ N
indicates which port is used during communication.
By default, it is \fB50000\fP\&.
.TP
.BI \-\-key \ KEY
defines the authentication key used during communication.
This field is not mandatory but \fBit is recommended to define it\fP
as it will be necessary for other processes to communicate with the
service itself. By default, it is \fBNone\fP which
means that it will be auto\-generated by the main process when
running.
.UNINDENT
.sp
The application automatically detects the plugins that are installed in the system. It
is important that the installed plugins follows the name convention in order to be
correctly identified. In other case, the subcommands won\(aqt appear here. For more
details, see \fBBasePlugin\fP\&.
.INDENT 7.0
.TP
.B Returns
execution return code. Multiple return codes are possible:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fB0\fP means that the execution was successful.
.IP \(bu 2
\fB1\fP refers to a standard error happened during execution.
.IP \(bu 2
\fB127\fP indicates that no plugins were found or no plugins
can handle the parsed command line options.
.UNINDENT
.UNINDENT
.UNINDENT

.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS orcha.properties
.sp
When working with an Orcha project, properties are expected to be stored here. This module
serves as a global entry point in which execution settings are stored. There are four
attributes exposed:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%listen_address\fP
.IP \(bu 2
\fI\%port\fP
.IP \(bu 2
\fI\%authkey\fP
.IP \(bu 2
\fI\%extras\fP
.UNINDENT
.UNINDENT
.UNINDENT
.sp
One can either opt in for manually defining these attributes or leverage them
to the \fBManager\fP class or the entry points
of the subclasses.
.INDENT 0.0
.TP
.B orcha.properties.authkey  =  None
Authentication key used when creating a
\fI\%SyncManager\fP\&.
This option is directly taken from \fBmain\fP argument \fB\-\-authkey\fP,
unless overwritten or not set. In the latest scenario, the authorization key is generated
from the current process.
.INDENT 7.0
.TP
.B See
\fI\%SyncManager\fP
.TP
.B See also
.INDENT 7.0
.IP \(bu 2
\fI\%authkey\fP
.IP \(bu 2
\fI\%current_process\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.properties.extras  =  {}
Extra properties that you may want to store when working with the project. By default, all
arguments are stored here in the form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "listen_address": "127.0.0.1",
    "port": 50000,
    "authkey": b"1234567890",
    "OtherArgumentsProvided": value,
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In addition, this field is open for adding new arguments that you may need.
.UNINDENT
.INDENT 0.0
.TP
.B orcha.properties.listen_address  =  \(aq127.0.0.1\(aq
Listen address used when defining a \fI\%SyncManager\fP\&.
This option is directly taken from \fBmain\fP argument \fB\-\-listen\-address\fP,
unless overwritten.
.INDENT 7.0
.TP
.B See
\fI\%SyncManager\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.properties.port  =  50000
Port used when creating a \fI\%SyncManager\fP\&.
This option is directly taken from \fBmain\fP argument \fB\-\-port\fP,
unless overwritten.
.INDENT 7.0
.TP
.B See
\fI\%SyncManager\fP
.UNINDENT
.UNINDENT
.SS Library
.SS orcha.exceptions
.sp
Orcha globally used exceptions
.INDENT 0.0
.TP
.B exception  orcha.exceptions.ManagerShutdownError
Bases: \fI\%Exception\fP
.sp
Specific exception raised when trying to attach a new process to a
manager when the manager is going to shut down. Applies the same when
trying to signal a process on a dying manager.
.sp
Used in classes such as \fI:class:\(gaManager <orcha.lib.manager.Manager>\fP\&.\(ga
.INDENT 7.0
.TP
.B See
\fI\%Exception\fP
.UNINDENT
.UNINDENT
.SS orcha.interfaces
.sp
\fBinterfaces\fP defines the basic structure needed when communicating with Orcha
.INDENT 0.0
.TP
.B class  orcha.interfaces.EmptyPetition
Bases: \fI\%orcha.interfaces.petition.Petition\fP
.sp
Empty petition which will run always the latest (as its priority is \fBinf\fP).
This petition is used in \fBManager\fP for indicating that there won\(aqt be
any new petitions after this one, so the \fBProcessor\fP can shut down.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This class accepts no parameters, and you can use it whenever you want for
debugging purposes. Notice that it is immutable, which means that no attribute
can be altered, added or removed once it has been initialized.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.interfaces.Message(id, extras)
Bases: \fI\%object\fP
.sp
Message interface accepted by the server. No other type will be parsed or
understood, so fit your needs to this structure.
.sp
By default, all \fI\%id\fP must be unique, so any message with a duplicated
identifier will be immediately rejected.
.sp
Any other parameter you need to pass can be fitted inside \fI\%extras\fP, as
a form of a dictionary. Take into account that the message is pickled and sent
over a network connection (or a UNIX socket), so any extra attribute placed there
must be pickable (it is, implement \fB__reduce__\fP method).
.INDENT 7.0
.TP
.B See
\fI\%pickle\fP
.UNINDENT
.INDENT 7.0
.TP
.B extras
Arbitrary dictionary containing any extra information required for converting
your \fI\%Message\fP into a \fI\%Petition\fP\&. Take into account that every
item placed here must be pickable. In other case, the message cannot be sent
to the server.
.INDENT 7.0
.TP
.B See
\fI\%pickle\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B id
Unique identifier for the message. If duplicated, the message is rejected.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.interfaces.Petition(id, queue, action, condition)
Bases: \fI\%abc.ABC\fP
.sp
Class that represents a petition that should be executed on the server.
This class must have the ability to being created from an existing
\fI\%Message\fP, as this is the only item that can be exchanged during
inner process communication.
.sp
It is composed by multiple attributes:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%priority\fP defines the priority of the petition.
.IP \(bu 2
\fI\%id\fP is a unique identifier for the petition.
.IP \(bu 2
\fI\%queue\fP is a \fI\%Queue\fP that can
be sent across processes.
.IP \(bu 2
\fI\%action\fP represents the callable that will be executed.
.IP \(bu 2
\fI\%condition\fP is a predicate which defines whether the petition
can be run or not.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This class is intended to be a stub so your implementation must inherit
from this one.
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
Subclasses must declare fields with \fBcompare=False\fP
as without that the algorithm may break and items are not placed in the order
you expect.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B See
\fI\%field\fP
.UNINDENT
.INDENT 7.0
.TP
.B action
The action to be called when the petition is pop from the queue. It is a function with the
form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
def action(cb: (Union[subprocess.Popen, int]) \-> None, p: Petition) \-> None
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Notice that the action will
be built on "server side", meaning that this attribute will default to \fI\%None\fP at the
beginning (functions cannot be shared across processes).
.sp
As a \fI\%Petition\fP is built from \fI\%Message\fP, use the \fI\%Message.extras\fP for
defining how the petition will behave when \fI\%action\fP is called.
.UNINDENT
.INDENT 7.0
.TP
.B condition
Predicate that decides whether the request should be processed or not. It is a function
with the form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
def predicate(p: Petition) \-> bool
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If your petitions do not require any particular condition, you can always define an
empty predicate which always returns \fI\%True\fP:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
petition = Petition(..., condition=lambda _: True)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B id
Unique identifier for this petition. This value must directly be extracted from
\fI\%Message.id\fP\&.
.UNINDENT
.INDENT 7.0
.TP
.B priority
Priority of the petition. It is an integer whose value is used for comparing
across other petitions. The lower the value is, the higher the priority gets.
Items with the same priority may keep input order, but it is not guaranteed.
.UNINDENT
.INDENT 7.0
.TP
.B queue
\fI\%Queue\fP used for process communication. Actually,
this queue is used as a one\-sided pipe in which the server puts the messages of
the \fI\%action\fP and finishes with a known exit code (i.e.: \fI\%None\fP, \fBint\fP, ...).
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
This queue \fBmust\fP be a
\fI\%proxy object\fP
which addresses a memory location on a
\fI\%Manager\fP\&. You can decide
to use your own queue given by \fI\%multiprocessing\fP but it probably won\(aqt work.
It is better to use the exposed manager for obtaining a queue once the client is
initialized: \fBManager.manager\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.interfaces.ServiceWrapper(manager, context=None)
Bases: \fI\%object\fP
.sp
Simple \fI\%dataclass\fP which contains the required parameters
for defining a service. The required one is \fI\%manager\fP, which allows and starts the
execution of petitions.
.sp
\fI\%context\fP is optional and defaults to \fI\%None\fP\&. In this case, a foreground service
is started and attached to the current session. If given, then a daemon is started with
the required parameters.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
You can use the \fI\%register_service()\fP for defining an instance of this class
easily and guided, for a background service running as a daemon. If you want a
foreground service, just create an instance of this class only with the
\fBManager\fP and call \fI\%start_service()\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.interfaces import ServiceWrapper, start_service

manager = ...
service = ServiceWrapper(manager)
exit(start_service(service))
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B See
\fI\%daemon.DaemonContext\fP
.UNINDENT
.INDENT 7.0
.TP
.B context  =  None
Context used for defining how the daemon will behave when started the process.
If \fI\%None\fP (the default), this service will behave like a foreground service
and will be attached to the current session.
.sp
Use the \fI\%register_service()\fP helper function for defining the \fBDaemonContext\fP
object easily, or build your own.
.INDENT 7.0
.TP
.B See
\fI\%daemon.DaemonContext\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B manager
Holds an instance to a \fBManager\fP object containing all the required attributes
for running. When \fI\%context\fP is resolved, this instance is used for starting
communication and listen to petitions.
.INDENT 7.0
.TP
.B See
\fBManager\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.interfaces.register_service(manager, *, pidfile=None, fds=None, user=None, group=None, cwd=\(aq/\(aq, stop_signal=Signals.SIGTERM)
Helper function to register a service with the given manager.
By default, the created service will behave like a foreground service
but without any session associated to it, and making impossible to
finish it as no PID file is created.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmanager\fP (\fIManager\fP) \-\- manager instance associated with the service.
.IP \(bu 2
\fBpidfile\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) \-\- filename in which PID will be stored. Defaults to None.
.IP \(bu 2
\fBfds\fP (\fIIterable\fP\fI[\fP\fI\%int\fP\fI]\fP\fI, \fP\fIoptional\fP) \-\- file descriptors to keep open when forking.
Defaults to None.
.IP \(bu 2
\fBuser\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) \-\- username to run the daemon as. Defaults to None.
.IP \(bu 2
\fBgroup\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) \-\- group to run the daemon as. Defaults to None.
.IP \(bu 2
\fBcwd\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) \-\- working directory to cd after forking. Defaults to "/".
.IP \(bu 2
\fBstop_signal\fP (\fI\%int\fP\fI, \fP\fIoptional\fP) \-\- signal expected to receive for finishing.
Defaults to \fBsignal.SIGTERM\fP\&.
.UNINDENT
.TP
.B Returns
a ready\-to\-use service to be passed to \fI\%start_service()\fP\&.
.TP
.B Return type
ServiceWrapper
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.interfaces.start_service(service)
Helper function that starts the service as a demon or in the foreground,
depending on \fI\%ServiceWrapper.context\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
For defining a foreground service, leave the \fI\%ServiceWrapper.context\fP attribute
to \fI\%None\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBservice\fP (\fIServiceWrapper\fP) \-\- service specifications object.
.TP
.B Returns
return code of the process. If on foreground, this function never returns
and just finished the hole Python interpreter.
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS orcha.lib
.sp
Modules used alongside Orcha environment. This package contains the core of the
orchestrator itself, exposing two main classes:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%Manager\fP, for handling requests and petitions.
.IP \(bu 2
\fI\%Processor\fP, which receives requests and manages executions.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
A plugin/package must inherit from \fI\%Manager\fP and define its own behavior
either as a server or as a client. Further details are exposed in there.
.sp
\fI\%Processor\fP is automatically defined based on the expected behavior of
\fI\%Manager\fP, so there is no need to inherit from that class.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fI\%Processor\fP is a singleton, which means that \fBonly exists an instance\fP\&.
This way, you can call the constructor after initialized as much as you want
that you will get always the same object. This helps to handle the messages,
signals and other petitions globally on the system without any collision in
between them
.UNINDENT
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.TP
.B class  orcha.lib.ClientManager(listen_address=\(aq127.0.0.1\(aq, port=50000, auth_key=None)
Bases: \fI\%orcha.lib.manager.Manager\fP
.sp
Simple \fI\%Manager\fP that is intended to be used by clients, defining the expected common
behavior of this kind of managers.
.sp
By default, it only takes the three main arguments: \fBlisten_address\fP, \fBport\fP and
\fBauth_key\fP\&. The rest of the params are directly fulfilled and leveraged to the parent’s
constructor.
.sp
In addition, the required abstract methods are directly overridden with no further action
rather than throwing a \fI\%NotImplementedError\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This class defines no additional behavior rather than the basic one. Actually, it is
exactly the same as implementing your own one as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.lib import Manager

class ClientManager(Manager):
    def __init__(self):
        super().__init__(is_client=True)

    def convert_to_petition(self, *args):
        pass

    def on_start(self, *args):
        pass

    def on_finish(self, *args):
        pass
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The main point is that as all clients should have the behavior above a generic base
class is given, so you can define as many clients as you want as simple as doing:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.lib import ClientManager

class MyClient(ClientManager): pass
class MyOtherClient(ClientManager): pass
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and define, if necessary, your own behaviors depending on parameters, attributes, etc.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlisten_address\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) – address used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBlisten_address\fP\&.
.IP \(bu 2
\fBport\fP (\fI\%int\fP\fI, \fP\fIoptional\fP) – port used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBport\fP\&.
.IP \(bu 2
\fBauth_key\fP (\fI\%bytes\fP\fI, \fP\fIoptional\fP) – authentication key used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBauthkey\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B convert_to_petition(_)
.INDENT 7.0
.TP
.B Raises
\fI\%NotImplementedError\fP – 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B on_finish(_)
.INDENT 7.0
.TP
.B Raises
\fI\%NotImplementedError\fP – 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B on_start(_)
.INDENT 7.0
.TP
.B Raises
\fI\%NotImplementedError\fP – 
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.lib.Manager(listen_address=\(aq127.0.0.1\(aq, port=50000, auth_key=None, create_processor=True, queue=None, finish_queue=None, is_client=False)
Bases: \fI\%abc.ABC\fP
.sp
\fI\%Manager\fP is the object an application must inherit from in order to work with
Orcha. A \fI\%Manager\fP encapsulates all the logic behind the application, making
easier to handle all incoming petitions and requests.
.sp
The expected workflow for a class inheriting from \fI\%Manager\fP is:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
┌─────────────────────┐                 ┌───────────────────┐
│                     │  not is_client  |                   |
|      Manager()      ├────────────┬───►|    Processor()    ├──────────┬─────...────┐
│                     │            |    |                   |          |            |
└──────────┬──────────┘            |    └───────────────────┘       Thread 1 ... Thread n
       over|ride                   |
           ├─────────────────────┐ |    ┌───────────────────┐
           |       not is_client | |    |                   | signal  ┌──────────────┐
           |                     | └───►|  serve()/start()  ├────────►|  shutdown()  |
           |                     |      |                   |         └──────────────┘
           |                     |      └───────────────────┘
           |                     |
           |             ┌───────┴──────┬────────────────────┐
           ▼             ▼              ▼                    ▼
     ┌───────────┐ ┌────────────┐ ┌─────────────┐ ┌─────────────────────┐
     |  setup()  | | on_start() | | on_finish() | | convert_to_petition |
     └───────────┘ └────────────┘ └─────────────┘ └─────────────────────┘

                                         is_client
                                         ────┬────
                                             |
                                             |            ┌─────────────┐
                                             ├───────────►|  connect()  |
                                             |            └─────────────┘
                                             |           ┌───────────────┐
                                             ├──────────►| send(message) |
                                             |           └───────────────┘
                                             |          ┌─────────────────┐
                                             ├─────────►| finish(message) |
                                             |          └─────────────────┘
                                             |            ┌────────────┐
                                             └───────────►| shutdown() |
                                                          └────────────┘
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This means that your class must override \fI\%setup()\fP with your own implementation as
well as \fI\%on_start()\fP and \fI\%on_finish()\fP\&. In addition, there is another method
\fI\%convert_to_petition()\fP that your server must implement, which allows passing from
a \fBMessage\fP object to a \fBPetition\fP one (this method call is used by
\fI\%Processor\fP).
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
The \fI\%Manager\fP is an abstract class and the methods above are abstract also,
which means that you are forced to implement them. On your client managers, you
can opt in for raising an exception on \fI\%on_start()\fP, \fI\%on_finish()\fP and
\fI\%convert_to_petition()\fP, as they will never (\fIshould\fP) be called:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.lib import Manager

class MyClient(Manager):
    def on_start(self, *args):
        raise NotImplementedError()

    def on_finish(self, *args):
        raise NotImplementedError()

    def convert_to_petition(self, *args):
        raise NotImplementedError()
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Once finished, both clients and servers must call \fI\%shutdown()\fP for finishing any
pending petition before quitting. If not called, some garbage can left and your code
will be prone to memory leaks.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlisten_address\fP (\fI\%str\fP\fI, \fP\fIoptional\fP) – address used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBlisten_address\fP\&.
.IP \(bu 2
\fBport\fP (\fI\%int\fP\fI, \fP\fIoptional\fP) – port used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBport\fP\&.
.IP \(bu 2
\fBauth_key\fP (\fI\%bytes\fP\fI, \fP\fIoptional\fP) – authentication key used when declaring a
\fI\%Manager\fP
object. Defaults to
\fBauthkey\fP\&.
.IP \(bu 2
\fBcreate_processor\fP (\fI\%bool\fP\fI, \fP\fIoptional\fP) – whether to create a \fI\%Processor\fP object or not.
The decision depends also on the \fBis_client\fP, as
clients don’t have any processor attached.
Defaults to \fI\%True\fP\&.
.IP \(bu 2
\fBqueue\fP (\fIQueue\fP\fI, \fP\fIoptional\fP) – optional queue used when receiving petitions from clients.
If not given, uses its own one. Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBfinish_queue\fP (\fIQueue\fP\fI, \fP\fIoptional\fP) – optional queue used when receiving signals from clients.
If not given, uses its own one. Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBis_client\fP (\fI\%bool\fP\fI, \fP\fIoptional\fP) – whether if the current manager behaves like a client or not,
defining different actions on function calls.
Defaults to \fI\%False\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B connect()
Connects to an existing \fI\%Manager\fP when acting as a client. This
method can be used also when the manager is a server, if you want that
server to behave like a client.
.UNINDENT
.INDENT 7.0
.TP
.B abstract  convert_to_petition(m)
With the given message, returns the corresponding \fBPetition\fP object
ready to be executed by \fI\%processor\fP\&.
.sp
This method must be implemented by subclasses, in exception to clients as they
do not need to worry about converting the message to a petition. Nevertheless,
clients must implement this function but can decide to just thrown an exception.
.INDENT 7.0
.TP
.B Parameters
\fBm\fP (\fIMessage\fP) – the message to convert
.TP
.B Returns
the converted petition, if valid
.TP
.B Return type
Optional[Petition]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B finish(message)
Requests the ending of a running \fBmessage\fP\&.
This method is a stub until \fI\%setup()\fP is called (as that function overrides it).
.sp
If the manager hasn’t been shutdown, enqueues the request and exists immediately.
Further processing is leveraged to the processor itself.
.INDENT 7.0
.TP
.B Parameters
\fBmessage\fP (\fIUnion\fP\fI[\fP\fIMessage\fP\fI, \fP\fI\%int\fP\fI]\fP) – the message to finish. If it is an \fI\%int\fP,
then the message
\fBid\fP is
assumed as the argument.
.TP
.B Raises
\fBManagerShutdownError\fP – if the manager has been shutdown and a new finish request
    has been tried to enqueue.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B is_running(x)
With the given arg, returns whether the petition is already
running or not yet. Its state can be:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Enqueued but not executed yet.
.IP \(bu 2
Executing right now.
.IP \(bu 2
Executed and finished.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBx\fP (\fIUnion\fP\fI[\fP\fIMessage\fP\fI, \fP\fIPetition\fP\fI, \fP\fI\%int\fP\fI]\fP) – the message/petition/identifier to check for
its state.
.TP
.B Raises
\fI\%NotImplementedError\fP – if trying to run this method as a client
.TP
.B Returns
whether if the petition is running or not
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B join()
Waits until the internal \fI\%SyncManager\fP
has finished all its work (it is,
\fI\%shutdown()\fP has been called).
.UNINDENT
.INDENT 7.0
.TP
.B manager
A \fI\%SyncManager\fP object which
is used for creating proxy objects for process communication.
.UNINDENT
.INDENT 7.0
.TP
.B abstract  on_finish(petition)
Action to be run when a \fBPetition\fP has started
its execution, in order to manage how the manager will react to other petitions when
enqueued (i.e.: to have a control on the execution, how many items are running, etc.).
.sp
By default, it just removes the petition ID from the running process set. Client managers
do not need to implement this method, so they can just throw an exception.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This method is intended to be used for managing requests queues and how are
they handled depending on, for example, CPU usage. For a custom behavior
on execution finish, please better use
\fBaction\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
It is \fBfundamental\fP that child server managers call \fBsuper()\fP on this
method, as not doing this will break the non\-duplicates algorithm:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.lib import Manager

class ServerManager(Manager):
    ...

    def on_finish(self, *args) \-> bool:
        existed = super().on_finish(*args)
        if existed:
            # do your stuff
            ...
        return existed
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Notice that the \fI\%on_finish()\fP returns a boolean value indicating whether
if the request for the \fBpetition\fP was successful
or not. A request is considered unsuccessful if one of the following conditions is met:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The current manager \fBis a client\fP\&.
.IP \(bu 2
The \fBpetition\fP was not registered (it is not
a running petition).
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBpetition\fP (\fIPetition\fP) – the petition that has just started
.TP
.B Returns
\fI\%True\fP if the finish request was successful, \fI\%False\fP otherwise.
.INDENT 7.0
.INDENT 3.5
A finish request is considered successful if the petition was registered
and running. See the warning above to know which one is returned in each
situation.
.UNINDENT
.UNINDENT

.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B abstract  on_start(petition)
Action to be run when a \fBPetition\fP has started
its execution, in order to manage how the manager will react to other petitions when
enqueued (i.e.: to have a control on the execution, how many items are running, etc.).
.sp
By default, it just saves the petition ID as a running process. Client managers
do not need to implement this method, so they can just throw an exception.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This method is intended to be used for managing requests queues and how are
they handled depending on, for example, CPU usage. For a custom behavior
on execution, please better use \fBaction\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
It is \fBfundamental\fP that child server managers call \fBsuper()\fP on this
method, as not doing this will break the non\-duplicates algorithm:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from orcha.lib import Manager

class ServerManager(Manager):
    ...

    def on_start(self, *args):
        super().on_start(*args)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBpetition\fP (\fIPetition\fP) – the petition that has just started
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B property  processor
\fI\%Processor\fP which handles all the queues and incoming requests,
running the specified \fBaction\fP when
the \fBcondition\fP evaluates to
\fI\%True\fP\&.
.INDENT 7.0
.TP
.B See
\fI\%Processor\fP
.TP
.B Raises
\fI\%RuntimeError\fP – if there is no processor attached or if the manager is a client
.TP
.B Returns
the processor object
.TP
.B Return type
Processor
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B register(name, func=None, **kwargs)
Registers a new function call as a method for the internal
\fI\%SyncManager\fP\&. In addition,
adds this method as an own function to the instance:
.sp
.nf
.ft C
>>> m = MyManager(...)
>>> m.register("hello", lambda: "Hello world!")
>>> print(m.hello())
Hello world!
.ft P
.fi
.sp
This method is very useful for defining a common function call in between
servers and clients. For more information, see
\fI\%register()\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Only \fBserver objects\fP have to define the behavior of the function;
clients can have the function argument empty:
.sp
.nf
.ft C
>>> m = ServerManager(...)
>>> m.register("hello", lambda: "Hello world!")
>>> m.start()  # the manager is started and is listening to petitions
>>> c = ClientManager(...)
>>> c.register("hello")
>>> c.connect()
>>> print(c.hello())  # the output is returned by the ServerManager
Hello world!
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B See
\fI\%register()\fP
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP (\fI\%str\fP) – name of the function/callable to add. Notice that this name
\fBmust match\fP in both clients and servers.
.IP \(bu 2
\fBfunc\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI]\fP\fI, \fP\fIoptional\fP) – object that will be called (by the server)
when a function with name \fBname\fP is
called. Defaults to \fI\%None\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B property  running_processes
Obtains the amount of processes that are currently running.
.INDENT 7.0
.TP
.B Raises
\fI\%NotImplementedError\fP – if trying to run this method as a client
.TP
.B Returns
amount of running processes
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(message)
Sends a \fBMessage\fP to the server manager.
This method is a stub until \fI\%setup()\fP is called (as that function overrides it).
.sp
If the manager hasn’t been shutdown, enqueues the
\fBmessage\fP and exits immediately.
Further processing is leveraged to the processor itself.
.INDENT 7.0
.TP
.B Parameters
\fBmessage\fP (\fIMessage\fP) – the message to enqueue
.TP
.B Raises
\fBManagerShutdownError\fP – if the manager has been shutdown and a new message
    has been tried to enqueue.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B serve()
Starts the internal \fI\%SyncManager\fP
but blocks until an external signal is caught.
.sp
If calling this method as a client, a warning is thrown.
.UNINDENT
.INDENT 7.0
.TP
.B setup()
Setups the internal state of the manager, registering two functions:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%send()\fP
.IP \(bu 2
\fI\%finish()\fP
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If running as a server, defines the functions bodies and sets the internal state of the
\fI\%manager\fP object. If running as a client, registers the method declaration itself
and leverages the execution to the remote manager.
.UNINDENT
.INDENT 7.0
.TP
.B shutdown()
Finishes the internal \fI\%SyncManager\fP
and stops queues from receiving new requests. A signal is emitted to the
\fI\%processor\fP and waits until all petitions have been processed.
.INDENT 7.0
.TP
.B See
\fI\%Processor.shutdown()\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B start()
Starts the internal \fI\%SyncManager\fP
and returns the control to the calling process.
.sp
If calling this method as a client a warning is thrown.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.lib.Processor(*args, **kwargs)
Bases: \fI\%object\fP
.sp
\fI\%Processor\fP is a \fBsingleton\fP whose responsibility is to handle and manage petitions
and signals collaborating with the corresponding \fI\%Manager\fP\&. This class has multiple
queues and threads for handling incoming requests. The following graph intends to show how
it works internally:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
┌─────────────────┐
|                 ├───────────────────────────────┐       ╔════════════════╗
|   Processor()   ├──────┬───────────────┐        ├──────►║ Message thread ║
|                 |      |               |        |       ╚═════╦══════════╝
└┬───────┬────────┘      |               |        |         ▲   ║   ╔═══════════════╗
 |       |               |               |        └─────────╫───╫──►║ Signal thread ║
 |       |               |               |                  ║   ║   ╚═══════╦═══════╝
 |       |               |               |                  ║   ║ t   ▲     ║
 |       ▼               |               ▼                  ║   ║ o   ║     ║
 | ┌───────────┐ send(m) |  ┌─────────────────────────┐     ║   ║     ║     ║
 | | Manager() ╞═════════╪═►   Message queue (proxy)   ═════╝   ║ p   ║     ║
 | └─────╥─────┘         ▼  └─────────────────────────┘         ║ e   ║     ║
 |       ║  finish(m)   ┌──────────────────────────┐            ║ t   ║     ║
 |       ╚═════════════►    Signal queue (proxy)    ════════════║═════╝     ║
 |                      └──────────────────────────┘            ║ i         ║
 |                                                              ║ t         ║
 |                                  Priority queue              ║ i         ║
 |                      ┌─────────────────────────┐             ║ o         ║
 |              ╔═══════  Internal petition queue  ◄═══════╦════╝ n         ║
 |              ║       └─────────────────────────┘        ║                ║
 |              ║           ┌─────────────────────────┐    ║                ║
 |              ║        ╔══   Internal signal queue   ◄═══║════════════════╝
 |              ║        ║  └─────────────────────────┘    ║
 |              ║        ║                                 ║      not
 |              ▼        ╚══════╗                          ║ p.condition(p)
 | ╔══════════════════════════╗ ║       ╔══════════════════╩═════╗
 ├►║ Internal petition thread ╠═║══════►║ Petition launch thread ║
 | ╚══════════════════════════╝ ▼       ╚══════════════════╤═════╝
 |       ╔════════════════════════╗                 ▲      |  ┌─────────────────────┐
 └──────►║ Internal signal thread ╠═════════════════╝      ├─►| manager.on_start(p) |
         ╚════════════════════════╝   send SIGTERM         |  └─────────────────────┘
                                                           |   ┌─────────────────┐
                                                           ├──►| p.action(fn, p) |
                                                           |   └─────────────────┘
                                                           | ┌──────────────────────┐
                                                           └►| manager.on_finish(p) |
                                                             └──────────────────────┘
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Ideally, you don’t need to create any instance for this class, as it is completely
managed by \fI\%Manager\fP (in particular, see
\fI\%processor\fP). The diagram above is posted for
informational purposes, as this class is big and can be complex in some situations
or without knowledge about multiprocessing. Below a detailed explanation on how
it works is added to the documentation so anyone can understand the followed
process.
.UNINDENT
.UNINDENT
.INDENT 7.0
.IP 1. 3
\fBQueues\fP
.UNINDENT
.sp
The point of having four \fI\%queues\fP is that messages are travelling
across threads in a safe way. When a message is received from another process, there is
some “black magic” going underneath the
\fI\%BaseManager\fP class involving pipes, queues
and other synchronization mechanisms.
.sp
With that in mind, take into account that messages are not received (yet) by our
process but by the manager server running on another IP and port, despite the fact that
the manager is ours.
.sp
That’s why a
\fI\%proxy\fP
object is involved in the entire equation. For summarizing, a proxy object is an object
that presumably lives in another process. In general, writing or reading data from a
proxy object causes every other process to notice our action (in terms that a new item
is now available for everyone, a deletion happens for all of them, etc).
.sp
If we decide to use \fI\%queues\fP instead, additions
or deletions won’t be propagated to the rest of the processes as it is a local\-only
object.
.sp
For that reason, there is four queues: two of them have the mission of receiving
the requests from other processes and once the request is received by us and is
available on our process, it is then added to an internal priority queue by the
handler threads (allowing, for example, sorting of the petitions based on their
priority, which wouldn’t be possible on a proxied queue).
.INDENT 7.0
.IP 2. 3
\fBThreads\fP
.UNINDENT
.sp
As you may notice, there is almost two threads per queue: one is a \fBproducer\fP and
the other one is the \fBconsumer\fP (following the producer/consumer model). The need
of so much threads (5 at the time this is being written) is \fBto not to block\fP any
processes and leave the orchestrator free of load.
.sp
As the queues are synchronous, which means that the thread is forced to wait until
an item is present (see \fI\%Queue.get()\fP), waiting for petitions
will pause the entire main thread until all queues are unlocked sequentially, one after
each other, preventing any other request to arrive and being processed.
.sp
That’s the reason why there are two threads just listening to proxied queues and placing
the requests on another queue. In addition, the execution of the action is also run
asynchronously in order to not to block the main thread during the processing (this
also applies to the evaluation of the \fBcondition\fP
predicate).
.sp
Each time a new thread is spawned for a \fBPetition\fP, it is saved on a list of
currently running threads. There is another thread running from the start of the
\fBProcess\fP which is the \fBgarbage collector\fP, whose responsibility is to
check which threads on that list have finished and remove them when that happens.
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
When defining your own \fBaction\fP, take special
care on what you will be running as any deadlock may block the entire pipeline
forever (which basically is what deadlocks does). Your thread must be error\-free
or must include a proper error handling on the \fBserver manager object\fP\&.
.sp
This also applies when calling \fI\%shutdown()\fP, as the processor will wait until
all threads are done. In case there is any deadlock in there, the processor will
never end and you will have to manually force finish it (which may cause zombie
processes or memory leaks).
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBqueue\fP (\fI\%multiprocessing.Queue\fP\fI, \fP\fIoptional\fP) – queue in which new \fBMessage\fP s are
expected to be. Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBfinishq\fP (\fI\%multiprocessing.Queue\fP\fI, \fP\fIoptional\fP) – queue in which signals are expected to be.
Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBmanager\fP (\fI\%Manager\fP, optional) – manager object used for synchronization and action
calling. Defaults to \fI\%None\fP\&.
.UNINDENT
.TP
.B Raises
\fI\%ValueError\fP – when no arguments are given and the processor has not been initialized yet.
.UNINDENT
.INDENT 7.0
.TP
.B enqueue(m)
Shortcut for:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
processor.queue.put(message)
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBm\fP (\fIMessage\fP) – the message to enqueue
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B exists(m)
Checks if the given message is running or not
.INDENT 7.0
.TP
.B Parameters
\fBm\fP (\fIUnion\fP\fI[\fP\fIMessage\fP\fI, \fP\fI\%int\fP\fI]\fP) – the message to check or its
\fBid\fP
.TP
.B Returns
\fI\%True\fP if running, \fI\%False\fP if not.
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
A message is considered to not exist iff \fBit’s not running\fP, but can
be enqueued waiting for its turn.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B finish(m)
Sets a finish signal for the given message
.INDENT 7.0
.TP
.B Parameters
\fBm\fP (\fIUnion\fP\fI[\fP\fIMessage\fP\fI, \fP\fI\%int\fP\fI]\fP) – the message or its \fBid\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B property  running
Whether if the current processor is running or not
.UNINDENT
.INDENT 7.0
.TP
.B shutdown()
Finishes all the internal queues and threads, waiting for any pending requests to
finish (they are not interrupted by default, unless the signal gets propagated).
.sp
This method must be called when finished all the server operations.
.UNINDENT
.UNINDENT
.SS orcha.plugins
.sp
The plugins are part of the basic structure of Orcha. Plugins allow extended
functionality by using command line arguments and custom
\fBmanagers\fP and \fBpetitions\fP\&.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
By default, Orcha provides the complete structure for running and orchestrate
what you want, based on \fBactions\fP and
\fBconditions\fP\&. Nevertheless, there
is no code in there and the provided command line interface is just the
skeleton for further plugins to add their functionality.
.sp
That said, plugins are \fBmandatory\fP in order to work with Orcha.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.plugins.BasePlugin(subparser)
Bases: \fI\%abc.ABC\fP
.sp
When developing your own application, the plugins must inherit from this class, as
the basic expected structure is defined here.
.sp
There are three exposed attributes:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\%name\fP, which is the name of the command.
.IP \(bu 2
\fI\%aliases\fP, which are aliases for the command.
.IP \(bu 2
\fI\%help\fP, which is a help string for the command.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
In order to the plugin to work, you just need to inherit from this class
and define all the required properties, such as \fI\%name\fP\&. Orcha by
itself will find and load the plugin if everything is OK.
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
In order the above method to work, you \fBmust follow\fP an strict
import order/path in your application. If you have a look at the
\fBmain\fP,
you will notice that two requirements must be fullfilled:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
Your plugin/module must be named as \fBorcha_<YOUR_PLUGIN>\fP so Orcha can find it.
.IP 2. 3
Your plugin/module must export the plugin class directly with the name \fBplugin\fP\&.
You can do it by defining a variable with that name, an alias or something like
that at your script file or at your \fB__init__.py\fP file. You will be able to check
if it will work as in the following example:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
orcha_plugin/
├ __init__.py
└ myplugin.py
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
# myplugin.py
from orcha.plugins import BasePlugin

class MyPlugin(BasePlugin):
    ...
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
# __init__.py
from .myplugin import MyPlugin as plugin
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
.nf
.ft C
>>> import orcha_plugin
>>> orcha_plugin.plugin
<class \(aqorcha_plugin.myplugin.MyPlugin\(aq>
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Keep your plugin as simple as possible, as any further operation will cause an overall
load of the entire orchestrator and a delay in responses. That\(aqs why this class is kept
frozen, which means that you won\(aqt be able to change any attribute once it is created
by the orchestrator.
.UNINDENT
.UNINDENT
.sp
Once Orcha finds your plugin, the following operations will be done:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
When the constructor is called, the method \fI\%create_parser()\fP will be called
and you will be able to include your own commands, subcommands and arguments.
.sp
You don\(aqt need to do any special for detecting whether you will be called or not,
the class provides a method \fI\%can_handle()\fP which evaluates if the specified
commands can be managed by us.
.IP 2. 3
Once all the arguments have been parsed by the main function, they will be placed
in the \fBextras\fP attribute with the form:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
"argument\-name": value
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
in case you may need an easier way to access those attributes without the need
to hold the \fI\%Namespace\fP reference.
.IP 3. 3
If the provided command is for you, the \fI\%handle()\fP method will be called
and you may start your own execution. In case your plugin is for a server, we
suggest you to use the \fBorcha.interfaces\fP module for defining
the behavior of it.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBsubparser\fP (\fIargparse.SubParser\fP) \-\- argument parser subparser in which you can add
your commands.
.UNINDENT
.INDENT 7.0
.TP
.B aliases  =  ()
Optional tuple containing aliases for your command
.UNINDENT
.INDENT 7.0
.TP
.B can_handle(owner)
Returns whether if the plugin can handle the input command or not
.INDENT 7.0
.TP
.B Parameters
\fBowner\fP (\fIBasePlugin\fP) \-\- instance that "owns" the input command.
.TP
.B Returns
\fI\%True\fP if the plugin can handle the command, \fI\%False\fP otherwise.
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B abstract  create_parser(parser)
Creates a parser that includes the subcommands and arguments required for
the plugin to work. The parser will be always a child from Orcha parser.
.INDENT 7.0
.TP
.B Parameters
\fBparser\fP (\fI\%argparse.ArgumentParser\fP) \-\- custom parser to work with Orcha
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B abstract  handle(namespace)
Handles the input command by probably running a main process.
.INDENT 7.0
.TP
.B Parameters
\fBnamespace\fP (\fI\%argparse.Namespace\fP) \-\- arguments received from CLI
.TP
.B Returns
main application return code, if any
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B help  =  None
Optional help string that will be shown when the user sets the "\fB\-\-help\fP" option on
your command
.UNINDENT
.INDENT 7.0
.TP
.B name
The name that your command will have, when called from the CLI
.UNINDENT
.INDENT 7.0
.TP
.B abstract  static  version()
Builds a version string that will be printed when the user requests the version
with the \fB\-\-version\fP option.
It is recommended that the version string has the form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
<PluginName> \- <PluginVersion>
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
the version identifier
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  orcha.plugins.ListPlugin(subparser)
Bases: \fI\%orcha.plugins.base.BasePlugin\fP
.sp
Simple embedded plugin that queries the installed plugins and defines a list with all of
them and their versions
.INDENT 7.0
.TP
.B create_parser(parser)
Creates a parser that includes the subcommands and arguments required for
the plugin to work. The parser will be always a child from Orcha parser.
.INDENT 7.0
.TP
.B Parameters
\fBparser\fP (\fI\%argparse.ArgumentParser\fP) \-\- custom parser to work with Orcha
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B handle(_)
Handles the input command by probably running a main process.
.INDENT 7.0
.TP
.B Parameters
\fBnamespace\fP (\fI\%argparse.Namespace\fP) \-\- arguments received from CLI
.TP
.B Returns
main application return code, if any
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  version()
Builds a version string that will be printed when the user requests the version
with the \fB\-\-version\fP option.
It is recommended that the version string has the form:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
<PluginName> \- <PluginVersion>
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Returns
the version identifier
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.plugins.query_plugins()
Query all installed plugins on the system. Notice that plugins must start with the
prefix \fBorcha_\fP and must export an object with name \fBplugin\fP which holds a reference
to a class inheriting from \fI\%BasePlugin\fP\&.
.INDENT 7.0
.TP
.B Returns
.INDENT 7.0
.TP
.B a dictionary whose keys are module names and the value is
the module itself.
.UNINDENT

.TP
.B Return type
\fI\%list\fP[BasePlugin]
.UNINDENT
.UNINDENT
.SS orcha.utils
.sp
Multiple utilities used across Orcha environment
.INDENT 0.0
.TP
.B orcha.utils.get_logger()
Generates (or returns) an existing logger from the system
that should be used globally on this program.
.INDENT 7.0
.TP
.B Returns
the system logger
.TP
.B Return type
\fI\%logging.Logger\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.utils.kill_proc_tree(pid, including_parent=True, sig=Signals.SIGTERM)
Attempts to kill the given PID and all of its children by sending the given
signal, if sufficient permissions.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBpid\fP (\fI\%int\fP) \-\- the PID to kill alongside with its children.
.IP \(bu 2
\fBincluding_parent\fP (\fI\%bool\fP) \-\- whether to kill also the PID itself. Defaults to \fI\%True\fP\&.
.IP \(bu 2
\fBsig\fP (\fI\%int\fP) \-\- the signal to send to the processes. Defaults to \fBsignal.SIGTERM\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.utils.run_command(cmd, on_start=None, on_output=None, on_finish=None, cwd=None)
Runs a command in a "secure" environment redirecting stderr into stdout and
calling \fBon_output()\fP on every line (as they are being written).
.sp
The method accepts three functions which are used for defining a custom behavior
during execution:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBon_start()\fP receives the \fI\%Popen\fP object just
created, even before starting running something.
.IP \(bu 2
\fBon_output()\fP receives a UTF\-8 string corresponding with current command output.
.IP \(bu 2
\fBon_finish()\fP receives the program return code, so you can handle any errors
that may occur.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcmd\fP (\fI\%str\fP | \fI\%Collection\fP) \-\- the command to run.
Can be a \fI\%str\fP or an iterable. If a \fI\%str\fP is given
then \fI\%shlex.split()\fP is called for dividing the command.
.IP \(bu 2
\fBon_start\fP (\fICallable\fP\fI[\fP\fI[\fP\fI\%subprocess.Popen\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP) \-\- function to be run when the process has
just started. Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBon_output\fP (\fICallable\fP\fI[\fP\fI[\fP\fI\%str\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP) \-\- function to be called when the process outputs a line.
Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBon_finish\fP (\fICallable\fP\fI[\fP\fI[\fP\fI\%int\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP) \-\- function to be called when the process finishes.
Defaults to \fI\%None\fP\&.
.IP \(bu 2
\fBcwd\fP (\fI\%str\fP) \-\- working directory to move on when calling the command. Defaults to \fI\%None\fP\&.
.UNINDENT
.TP
.B Returns
command return code
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B orcha.utils.version(package)
Safely returns the version for an installed package on the system.
.INDENT 7.0
.TP
.B Parameters
\fBpackage\fP (\fI\%str\fP) \-\- the package to get its version
.TP
.B Returns
package version
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
Javier Alonso <jalonso@teldat.com>
.SH COPYRIGHT
2021, Javier Alonso <jalonso@teldat.com>
.\" Generated by docutils manpage writer.
.
